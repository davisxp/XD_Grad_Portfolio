<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Model Viewer</title>
  <meta name="description" content="Live preview of portfolio spreadsheets with formula inspector" />
  <style>
    :root{
      --bg:#0b0c0f; --panel:#141821; --muted:#7f8aa3; --border:#202636; --text:#e7eaf0; --accent:#5bb98b;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans";
      --cellw: 180px;       /* default column width */
      --rowheadw: 64px;     /* row-header width */
    }
    @media (prefers-color-scheme: light) {
      :root{ --bg:#ffffff; --panel:#f7f8fb; --muted:#515f7a; --border:#e7eaf0; --text:#0b0c0f; --accent:#17664b; }
    }
    @media (max-width: 1100px){
      :root{ --cellw: 150px; --rowheadw: 56px; }
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:var(--sans); background:var(--bg); color:var(--text);
      display:grid; grid-template-rows:auto 1fr;
    }
    header{
      display:flex; gap:12px; align-items:center; padding:14px 16px; border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, var(--panel), transparent 100%);
      position:sticky; top:0; z-index:10;
    }
    h1{margin:0; font-size:16px; font-weight:600}
    .spacer{flex:1}
    .btn, select, input[type="text"]{
      background:transparent; color:var(--text); border:1px solid var(--border); border-radius:10px;
      padding:8px 10px; font-size:14px;
    }
    .btn:hover{border-color:var(--accent)}
    .btn.primary{background:var(--accent); color:white; border-color:var(--accent)}
    .toolbar{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--border); border-radius:999px}
    main{display:grid; grid-template-columns:1fr 340px; gap:14px; padding:14px; min-height:0}
    aside{
      border-left:1px solid var(--border); padding-left:14px;
      display:flex; flex-direction:column; gap:12px; min-height:0;
    }
    .panel{
      background:var(--panel); border:1px solid var(--border); border-radius:12px;
      padding:12px; min-height:0;
    }
    .panel h2{margin:0 0 8px 0; font-size:14px}
    .meta{color:var(--muted); font-size:12px}
    #sheetWrap{background:var(--panel); border:1px solid var(--border); border-radius:12px; overflow:auto; min-height:0}
    table{
      border-collapse:collapse; font-size:13px; font-family:var(--mono);
      table-layout:fixed; min-width:100%;
    }
    th, td{
      border:1px solid var(--border); padding:6px 8px; vertical-align:top;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      min-width:0;
    }
    thead th{position:sticky; top:0; background:rgba(0,0,0,0.15); z-index:2}
    thead th.firstcol{left:0; z-index:3; box-shadow:2px 0 0 0 var(--border)}
    tbody th.firstcol{
      position:sticky; left:0; background:rgba(0,0,0,0.10); z-index:1; box-shadow:2px 0 0 0 var(--border)
    }
    /* Column sizing */
    thead th:not(.firstcol), tbody td:not(.firstcol){ width:var(--cellw); max-width:var(--cellw); }
    thead th.firstcol, tbody th.firstcol{ width:var(--rowheadw); min-width:var(--rowheadw); max-width:var(--rowheadw); }
    tbody tr:nth-child(even) td{background:rgba(255,255,255,0.02)}
    .error{color:#e87d7d}
    .kv{display:grid; grid-template-columns:110px 1fr; gap:6px 10px; font-family:var(--mono); font-size:12px}
    .kv b{color:var(--muted); font-weight:600}
    .kv span{white-space:pre-wrap; word-break:break-word}
    code{font-family:var(--mono); font-size:12px}
    .hidden{display:none}
    footer{border-top:1px solid var(--border); padding:12px 16px; color:var(--muted); font-size:12px}
    @media (max-width: 980px) {
      main{grid-template-columns:1fr}
      aside{border-left:none; padding-left:0}
    }
  </style>
  <!-- Sheet parser -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- Formula engine for live recalc -->
  <script src="https://cdn.jsdelivr.net/npm/hyperformula@3.0.1/dist/hyperformula.full.min.js"></script>
</head>
<body>
  <header>
    <a class="btn" href="../">Back to landing page</a>
    <h1>Live Spreadsheet Viewer</h1>
    <div class="spacer"></div>

    <div class="toolbar">
      <label class="pill">Workbook
        <select id="file" aria-label="Workbook"></select>
      </label>
      <label class="pill">Sheet
        <select id="sheet" aria-label="Sheet"></select>
      </label>
      <label class="pill">Scenario
        <select id="scenario" aria-label="Scenario"></select>
      </label>
      <label class="pill"><input type="checkbox" id="showFormula" aria-label="Show formulae"> Show formulae</label>
      <label class="pill">Filter <input id="filter" type="text" placeholder="Filter rows" aria-label="Filter rows"></label>
      <button class="btn" id="copyLink">Copy link</button>
      <a class="btn primary" id="downloadLink" download>Download</a>
    </div>
  </header>

  <main>
    <div id="sheetWrap"><div id="status" class="meta" style="padding:10px">Loading…</div><div id="out"></div></div>

    <aside>
      <div class="panel" id="inspector">
        <h2>Cell inspector</h2>
        <div class="meta">Click any cell to inspect value and formulae.</div>
        <div class="kv" id="cellInfo">
          <b>Address</b><span>–</span>
          <b>Value</b><span>–</span>
          <b>Raw</b><span>–</span>
          <b>Formula</b><span>–</span>
          <b>Type</b><span>–</span>
          <b>Format</b><span>–</span>
          <b>Hyperlink</b><span>–</span>
        </div>
      </div>
    </aside>
  </main>

  <footer>
    Tip: provide a “Summary” sheet in each workbook for a clean first render. Keep preview files under ~100 MB and outside Git LFS.
  </footer>

  <script>
    // === Configure your workbooks (case-sensitive paths) ===
    const files = [
      { path: "../models/3_Statement_Model.xlsx", label: "Smith & Nephew — 3-Statement" },
      { path: "../models/DCF_SN.xlsx",            label: "Smith & Nephew — DCF" }
    ];

    // === Scenario binding (EDIT THESE to match your model) ===
    const SCENARIO = {
      sheet: 'DCF',                    // sheet that holds your scenario input
      cell:  'G24',                    // input cell (e.g., Bear/Central/Bull)
      options: ['Bear','Central','Bull']
    };

    // === Cross-workbook support: list external files referenced by formulas ===
    const LINKED_FILES = ["../models/3_Statement_Model.xlsx"];

    // Performance soft cap for enormous sheets
    const MAX_R = 1500, MAX_C = 80;

    const fileSel   = document.getElementById('file');
    const sheetSel  = document.getElementById('sheet');
    const scenarioSel = document.getElementById('scenario');
    const out       = document.getElementById('out');
    const statusEl  = document.getElementById('status');
    const showForm  = document.getElementById('showFormula');
    const filterInp = document.getElementById('filter');
    const copyBtn   = document.getElementById('copyLink');
    const dlLink    = document.getElementById('downloadLink');

    let currentWB = null, currentPath = null, currentWS = null, currentHTMLTable = null;
    let hf = null;  // HyperFormula instance
    const sheetOffsets = {};      // { [sheetName]: {r0, c0} }
    const date1904BySheet = {};   // { [sheetName]: boolean }

    // Populate file + scenario dropdowns
    files.forEach(f => {
      const opt = document.createElement('option');
      opt.value = f.path; opt.textContent = f.label;
      fileSel.appendChild(opt);
    });
    fileSel.value = files[0].path;
    scenarioSel.innerHTML = SCENARIO.options.map(v => `<option value="${v}">${v}</option>`).join('');

    fileSel.addEventListener('change', () => loadWorkbook(fileSel.value));
    sheetSel.addEventListener('change', () => {
      const name = sheetSel.value;
      if (!currentWB) return;
      currentWS = currentWB.Sheets[name];
      renderSheet(currentWS);
      syncLink();
    });
    showForm.addEventListener('change', () => renderSheet(currentWS));
    filterInp.addEventListener('input', () => applyFilter());

    copyBtn.addEventListener('click', () => {
      const short = (currentPath||"").split('/').pop();
      const url = new URL(location.href);
      url.searchParams.set('file', short);
      url.searchParams.set('sheet', sheetSel.value);
      url.searchParams.set('f', showForm.checked ? "1":"0");
      url.searchParams.set('sc', scenarioSel.value);
      navigator.clipboard.writeText(url.toString()).then(() => {
        status('Link copied');
      }).catch(() => status('Could not copy link'));
    });

    function syncLink(){
      dlLink.href = currentPath;
      dlLink.textContent = 'Download ' + (files.find(f=>f.path===currentPath)?.label || 'workbook');
    }
    function status(t){ statusEl.textContent = t; }

    // Remove [Workbook.xlsx] qualifiers from formulas so HF can resolve cross-sheet refs
    function stripBookRefs(formula) {
      return formula.replace(/\[[^\]]+\]/g, '');
    }
    // Heuristic: does a number format look like a date/time?
    function isDateFmt(fmt){
      return typeof fmt === 'string' && /[dyhs]/i.test(fmt);
    }
    // Format an HF-evaluated value using the source cell's formatting where possible,
    // and fall back to a formatter derived from the saved display text (cell.w)
    function formatUsingCell(val, cell, sheetName){
      if (val === null || val === undefined) return '';
      // HF error object → show Excel's cached display (keeps the UI clean)
      if (val && typeof val === 'object' && 'type' in val) {
        return cell ? XLSX.utils.format_cell(cell) : '';
      }
      // Prefer explicit Excel number format if present
      if (cell && cell.z !== undefined) {
        try{
          let v = val;
          if (isDateFmt(cell.z) && date1904BySheet[sheetName]) v = Number(v) + 1462; // 1904 system
          return XLSX.SSF.format(cell.z, v);
        }catch{}
      }
      // Derive a formatter from the saved display text (cell.w)
      if (cell && typeof val === 'number' && typeof cell.w === 'string' && cell.w.trim()){
        const w = cell.w;
        const hasPct = /%/.test(w);
        const hasGBP = /£/.test(w);
        const mDec   = w.match(/\.([0-9]+)/);
        const decimals = mDec ? mDec[1].length : (hasPct ? 0 : 2);
        const useGrouping = /,/.test(w) || Math.abs(val) >= 1000;
        const opts = { maximumFractionDigits: decimals, minimumFractionDigits: decimals, useGrouping };
        let num = val;
        if (hasGBP){ opts.style = 'currency'; opts.currency = 'GBP'; }
        if (hasPct){ opts.style = 'percent'; }
        try{ return new Intl.NumberFormat('en-GB', opts).format(num); }catch{}
      }
      // Sensible default
      return (typeof val === 'number')
        ? new Intl.NumberFormat('en-GB').format(val)
        : String(val);
    }

    async function loadWorkbook(path){
      try{
        currentPath = path;
        status('Loading workbook…');
        out.innerHTML = '';
        sheetSel.innerHTML = '';
        const res = await fetch(path, { cache: 'no-store' });
        if(!res.ok) throw new Error(`Fetch failed (${res.status}) for ${path}`);
        const buf = await res.arrayBuffer();
        currentWB = XLSX.read(buf, { type: 'array' });

        // Load this workbook's number formats into SSF
        if (currentWB && currentWB.SSF) XLSX.SSF.load(currentWB.SSF);

        // Populate sheets
        currentWB.SheetNames.forEach(s => {
          const opt = document.createElement('option');
          opt.value = s; opt.textContent = s;
          sheetSel.appendChild(opt);
        });
        // Pick Summary if present, else first
        const initial = currentWB.SheetNames.includes('Summary') ? 'Summary' : currentWB.SheetNames[0];
        sheetSel.value = initial;
        currentWS = currentWB.Sheets[initial];

        // Build HyperFormula workbook from active + linked files
        await buildHF();

        // Initialise Scenario selector to current cell value, if possible
        initScenarioFromHF();

        // Render
        renderSheet(currentWS);
        status(`${path} • ${currentWB.SheetNames.length} sheet(s)`);

        // Reflect in download link
        syncLink();
      }catch(e){
        out.innerHTML = `<div class="error">${e.message}. Check the file path (case-sensitive), ensure the workbook is under 100 MB, and not stored via Git LFS.</div>`;
        status('Error loading workbook');
      }
    }

    async function buildHF(){
      if (!window.HyperFormula) { hf = null; return; }
      if (hf && hf.destroy) hf.destroy();

      // fetch and parse current + linked workbooks
      const paths = [currentPath, ...LINKED_FILES.filter(p => p !== currentPath)];
      const workbooks = [];
      for (const p of paths) {
        const res = await fetch(p, { cache: 'no-store' });
        if (!res.ok) throw new Error(`Fetch failed (${res.status}) for ${p}`);
        const buf = await res.arrayBuffer();
        const wb = XLSX.read(buf, { type: 'array' });
        // Merge number formats from linked files too
        if (wb && wb.SSF) XLSX.SSF.load(wb.SSF);
        workbooks.push({ path: p, wb });
      }

      const sheetsData = {};
      for (const { wb } of workbooks) {
        const date1904 = !!(wb.Workbook && wb.Workbook.WBProps && wb.Workbook.WBProps.date1904);
        for (const name of wb.SheetNames) {
          const ws = wb.Sheets[name];
          const ref = ws['!ref'] || 'A1:A1';
          const r = XLSX.utils.decode_range(ref);
          const rows = r.e.r - r.s.r + 1, cols = r.e.c - r.s.c + 1;
          const aoa  = Array.from({length: rows}, () => Array(cols).fill(null));
          for (let R=r.s.r; R<=r.e.r; ++R){
            for (let C=r.s.c; C<=r.e.c; ++C){
              const addr = XLSX.utils.encode_cell({r:R,c:C});
              const cell = ws[addr];
              if (!cell) continue;
              if (cell.f) {
                aoa[R - r.s.r][C - r.s.c] = "=" + stripBookRefs(cell.f);
              } else {
                aoa[R - r.s.r][C - r.s.c] = (cell.v ?? null);
              }
            }
          }
          const key = name; // assumes unique sheet names
          sheetsData[key] = aoa;
          sheetOffsets[key] = { r0: r.s.r, c0: r.s.c };
          date1904BySheet[key] = date1904;
        }
      }

      hf = HyperFormula.HyperFormula.buildFromSheets(sheetsData, { licenseKey: 'gpl-v3' });

      // Wire scenario change → write to sheet and re-render
      scenarioSel.onchange = () => {
        try {
          const id = hf.getSheetId(SCENARIO.sheet);
          const {r,c} = XLSX.utils.decode_cell(SCENARIO.cell);
          const {r0,c0} = sheetOffsets[SCENARIO.sheet] || {r0:0,c0:0};
          hf.setCellContents({ sheet: id, row: r - r0, col: c - c0 }, [[scenarioSel.value]]);
          renderSheet(currentWS);
          status('Scenario updated');
        } catch(e) {
          status('Scenario update failed: ' + e.message);
        }
      };
    }

    function initScenarioFromHF(){
      try {
        if (!hf) return;
        const id = hf.getSheetId(SCENARIO.sheet);
        const {r,c} = XLSX.utils.decode_cell(SCENARIO.cell);
        const {r0,c0} = sheetOffsets[SCENARIO.sheet] || {r0:0,c0:0};
        const curVal = hf.getCellValue({ sheet: id, row: r - r0, col: c - c0 });
        if (curVal != null) {
          const s = String(curVal);
          if (SCENARIO.options.includes(s)) scenarioSel.value = s;
        }
        // Honour deep link ?sc=
        const params = new URLSearchParams(location.search);
        const qSc = params.get('sc');
        if (qSc && SCENARIO.options.includes(qSc)) {
          scenarioSel.value = qSc;
          hf.setCellContents({ sheet: id, row: r - r0, col: c - c0 }, [[scenarioSel.value]]);
        }
      } catch(_) {}
    }

    function renderSheet(ws){
      if(!ws) return;
      const activeSheetName = sheetSel.value;
      const activeSheetId = hf ? hf.getSheetId(activeSheetName) : null;

      // Determine render range
      const ref = ws['!ref'] || 'A1:A1';
      const range = XLSX.utils.decode_range(ref);
      const rowOffset = range.s.r, colOffset = range.s.c;
      range.e.r = Math.min(range.e.r, range.s.r + MAX_R - 1);
      range.e.c = Math.min(range.e.c, range.s.c + MAX_C - 1);

      const table = document.createElement('table');

      // Build head with corner + column letters
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      const thCorner = document.createElement('th'); thCorner.className='firstcol'; trh.appendChild(thCorner);
      for(let C=range.s.c; C<=range.e.c; ++C){
        const th = document.createElement('th');
        th.textContent = XLSX.utils.encode_col(C);
        th.setAttribute('scope','col');
        trh.appendChild(th);
      }
      thead.appendChild(trh);
      table.appendChild(thead);

      // Build body
      const tbody = document.createElement('tbody');
      for(let R=range.s.r; R<=range.e.r; ++R){
        const tr = document.createElement('tr');
        const rowHead = document.createElement('th');
        rowHead.className='firstcol';
        rowHead.textContent = (R+1);
        rowHead.setAttribute('scope','row');
        tr.appendChild(rowHead);

        for(let C=range.s.c; C<=range.e.c; ++C){
          const addr = XLSX.utils.encode_cell({r:R,c:C});
          const td = document.createElement('td');
          const cell = ws[addr];
          td.dataset.address = addr;

          // Decide display text: formula (if toggled), else evaluated value via HF (formatted), else Excel's cached display
          let displayText = '';
          if (showForm.checked && cell && cell.f) {
            displayText = "=" + (cell.f || '');
          } else if (hf && activeSheetId != null) {
            const hfRow = R - rowOffset, hfCol = C - colOffset;
            const val = hf.getCellValue({ sheet: activeSheetId, row: hfRow, col: hfCol });
            displayText = formatUsingCell(val, cell, activeSheetName);
          } else {
            displayText = cell ? XLSX.utils.format_cell(cell) : '';
          }

          td.textContent = displayText;
          // tooltip with full content or formula
          td.title = (cell && cell.f) ? ("=" + cell.f)
                   : (cell && cell.v !== undefined ? String(cell.v) : displayText);
          if(cell && cell.t === 'n' && !cell.f) td.style.textAlign = 'right';

          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);

      // Mount
      out.innerHTML = '';
      out.appendChild(table);
      currentHTMLTable = table;

      // interactions (persistent)
      table.addEventListener('click', onCellClick);
      applyFilter();
    }

    function onCellClick(ev){
      const td = ev.target.closest('td');
      if(!td || !td.dataset.address) return;
      const addr = td.dataset.address;
      const cell = currentWS[addr] || {};
      const fmt  = XLSX.utils.format_cell(cell);
      const info = {
        Address: addr,
        Value: fmt || '',
        Raw: (cell.v!==undefined ? String(cell.v) : ''),
        Formula: (cell.f ? "="+cell.f : ''),
        Type: cell.t || '',
        Format: cell.z || '',
        Hyperlink: (cell.l && (cell.l.Target || cell.l.target)) ? (cell.l.Target || cell.l.target) : ''
      };
      const kv = document.getElementById('cellInfo');
      kv.innerHTML = '';
      Object.entries(info).forEach(([k,v])=>{
        const b = document.createElement('b'); b.textContent = k;
        const s = document.createElement('span'); s.textContent = v || '–';
        kv.appendChild(b); kv.appendChild(s);
      });
    }

    function applyFilter(){
      if(!currentHTMLTable) return;
      const q = (filterInp.value||'').toLowerCase();
      const rows = currentHTMLTable.querySelectorAll('tbody tr');
      rows.forEach(row=>{
        if(!q){ row.classList.remove('hidden'); return; }
        const text = row.textContent.toLowerCase();
        row.classList.toggle('hidden', !text.includes(q));
      });
    }

    // Deep-link support
    (function initFromQuery(){
      const params = new URLSearchParams(location.search);
      const qFile  = params.get('file');
      const qSheet = params.get('sheet');
      const qF     = params.get('f');
      const qSc    = params.get('sc');
      if(qF === '1') showForm.checked = true;

      if (qSc && SCENARIO.options.includes(qSc)) scenarioSel.value = qSc;

      if(qFile){
        const match = files.find(f => f.path.endsWith('/'+qFile) || f.label === qFile);
        if(match) fileSel.value = match.path;
      }
      loadWorkbook(fileSel.value).then(()=>{
        if(qSheet && currentWB.SheetNames.includes(qSheet)){
          sheetSel.value = qSheet;
          currentWS = currentWB.Sheets[qSheet];
          renderSheet(currentWS);
        }
      });
    })();
  </script>
</body>
</html>
